/** 
\mainpage OpenFLUID-engine SDK : Library API
 
\section oview_sec Overview

The OpenFLUID-engine library is part of the OpenFLUID-engine Source Development Kit (SDK) which also compounds an Eclipse-based Integrated Development Environment (IDE) and the documentation. It is used by the OpenFLUID-engine kernel and to develop simulation functions that can be used in flux models.  

The library mainly rely on two external libraries:
<ul> 
  <li>The base part of the wxWidgets library for strings and some data structures (hashmap, ...)  
  <li>The TinyXML library for XML file handling 
  <li>The C++ Standard Type Library (STL) for other data structures (list, vector)   
</ul>

\image html API_stack.png 
\image latex API_stack.png 
 
\n
\n 
   
\section use_sec How to use the OpenFLUID-engine library

\subsection genorg_ssec General organization
 
 The OpenFLUID-engine library is contained by the openfluid namespace, which is splitted into three parts: 
<ul>
  <li>openfluid::core, defined in openfluid-core.h, gathers all the classes for the shared data between the kernel and the functions, and between the functions themselves
  <li>openfluid::base, defined in openfluid-base.h, gathers all the classes for the dynamic interactions between the kernel and the functions, and in particular the openfluid::base::PluggableFunction class
  <li>openfluid::tools, defined in openfluid-tools.h, gathers tools available to process data, to build structures, to read files, ...
</ul>

\subsection feat_ssec Features 
 

\n
\n 

 
\section devfunc_sec How to develop a simulation function

\subsection devfuncempty_ssec Creating an empty function

A simulation function is composed of two entities :
<ul>
  <li>A signature, giving information about the function, and used by the kernel to identify functions
  <li>A C++ class, which must inherit from openfluid::base::PluggableFunction, defining essential methods 
</ul>
This two entities should be declared in a .h file and implemented in a .cpp file. They should be compiled through a makefile.
\note
An empty simulation function can be automatically generated through an OpenFLUID plugin for Eclipse, included in the SDK


\subsubsection devfuncemptysignature_ssec Writing the signature


\subsubsection devfuncemptyclass_ssec Writing the derivative class from openfluid::base::PluggableFunction 

  
\subsubsection devfuncemptyexample_ssec Example 

Example of an empty function, with the .h file, the .cpp file, and the makefile
   
Header File (.h)
\code
#ifndef __EXAMPLEFUNC_H__
#define __EXAMPLEFUNC_H__

#include "openfluid-base.h"
#include "openfluid-core.h"

// =====================================================================
// =====================================================================

DECLARE_PLUGIN_HOOKS;

// =====================================================================
// =====================================================================

class ExampleFunction : public openfluid::base::PluggableFunction
{
  private:

  public:
    /**
      Constructor
    */
    ExampleFunction();

    /**
      Destructor
    */
    ~ExampleFunction();

    bool initParams(openfluid::core::ParamsMap Params);

    bool prepareData();

    bool checkConsistency();

    bool initializeRun(const openfluid::base::SimulationInfo* SimInfo);

    bool runStep(const openfluid::base::SimulationStatus* SimStatus);

    bool finalizeRun(const openfluid::base::SimulationInfo* SimInfo);
};

#endif  // __EXAMPLEFUNC_H__
\endcode 



Implementation file (.cpp)  
\code

#include "ExampleFunc.h"

// =====================================================================
// =====================================================================

DEFINE_FUNCTION_HOOK(ExampleFunction);

// =====================================================================
// =====================================================================

BEGIN_SIGNATURE_HOOK
  DECLARE_SIGNATURE_ID(wxT("examplefunc"));
  DECLARE_SIGNATURE_NAME(wxT("Example Function"));
  DECLARE_SIGNATURE_DESCRIPTION(wxT(""));

  DECLARE_SIGNATURE_VERSION(wxT("1.0"));
  DECLARE_SIGNATURE_SDKVERSION;
  DECLARE_SIGNATURE_STATUS(openfluid::base::EXPERIMENTAL);

  DECLARE_SIGNATURE_DOMAIN(wxT(""));
  DECLARE_SIGNATURE_PROCESS(wxT(""));
  DECLARE_SIGNATURE_METHOD(wxT(""));
  DECLARE_SIGNATURE_AUTHORNAME(wxT(""));
  DECLARE_SIGNATURE_AUTHOREMAIL(wxT(""));
END_SIGNATURE_HOOK

// =====================================================================
// =====================================================================

ExampleFunction::ExampleFunction()
                : PluggableFunction()
{
  // here code for constructor
}

// =====================================================================
// =====================================================================

ExampleFunction::~ExampleFunction()
{
  // here code for destructor
}

// =====================================================================
// =====================================================================

bool ExampleFunction::initParams(openfluid::core::ParamsMap Params)
{
  // here code for function parameters initialization
  return true;
}

// =====================================================================
// =====================================================================

bool ExampleFunction::prepareData()
{
  // here code for data preparation befor consistency checking
  return true;
}

// =====================================================================
// =====================================================================

bool ExampleFunction::checkConsistency()
{
  // here code for function consistency checking
  return true;
}

// =====================================================================
// =====================================================================


bool ExampleFunction::initializeRun(const openfluid::base::SimulationInfo* SimInfo)
{
  // here code for initialization just before the simulation
  return true;
}

// =====================================================================
// =====================================================================

bool ExampleFunction::runStep(const openfluid::base::SimulationStatus* SimStatus)
{
  // here code for each time step
  return true;
}

// =====================================================================
// =====================================================================

bool ExampleFunction::finalizeRun(const openfluid::base::SimulationInfo* SimInfo)
{
  // here code for finalization just after the simulation
  return true;
}
\endcode 
 


Makefile
 
\verbatim
CPP = g++
WXLIBS = $(shell wx-config --libs base)
WXFLAGS = $(shell wx-config --cxxflags base)
OPENFLUIDLIBS = $(shell openfluid-config --libs)
OPENFLUIDFLAGS = $(shell openfluid-config --cflags)
BINFILE = examplefunc
SRCFILESROOT = ExampleFunc

INSTALLPATH = $(HOME)/.openfluid/engine/functions
OBJPATH = .
BINPATH = .

LDFLAGS =
PLUGEXT = sompi
ifeq ($(OSTYPE),msys)
  LDFLAGS=-Wl,--enable-runtime-pseudo-reloc
  PLUGEXT = dllmpi
endif

ifdef FORCEINSTALLPATH
  INSTALLPATH = $(FORCEINSTALLPATH)
endif

ifdef FORCEOBJPATH
  OBJPATH = $(FORCEOBJPATH)
endif

ifdef FORCEBINPATH
  BINPATH = $(FORCEBINPATH)
endif


all:
	$(CPP) -c $(SRCFILESROOT).cpp -o $(OBJPATH)/$(SRCFILESROOT).o -fPIC $(WXFLAGS) $(OPENFLUIDFLAGS)
	$(CPP) $(OBJPATH)/$(SRCFILESROOT).o $(WXLIBS) $(OPENFLUIDLIBS) -o $(BINPATH)/$(BINFILE).$(PLUGEXT) -shared $(LDFLAGS)

clean:
	rm -f $(BINPATH)/$(BINFILE).$(PLUGEXT)
	rm -f $(OBJPATH)/$(SRCFILESROOT).o

install: all
	 @mkdir -p $(INSTALLPATH)
	 @cp ./$(BINFILE).$(PLUGEXT) $(INSTALLPATH)
\endverbatim 

*/
