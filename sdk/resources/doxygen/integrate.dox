/**

\page integrate Developping the computational code



\section sign_sec Complete the signature

The signature can be automatically generated through the OpenFLUID plugin for Eclipse, included in the SDK. However it is possible to write the signature "from scratch".

The signature has to be defined between the #BEGIN_SIGNATURE_HOOK and #END_SIGNATURE_HOOK macros.  

\subsection signid_ssec Identification

The identification part of the signature must contain at least the ID of the simulation function. This ID will be used by the kernel to load functions. It is declared in the signature using the #DECLARE_SIGNATURE_ID macro.\n 
The others information that can be included for identification are:
<ul>
<li>the function name, declared through the #DECLARE_SIGNATURE_NAME macro
<li>the function description, declared through the #DECLARE_SIGNATURE_DESCRIPTION macro
<li>the name of the author, declared through the #DECLARE_SIGNATURE_AUTHORNAME macro
<li>the email of the author, declared through the #DECLARE_SIGNATURE_AUTHOREMAIL macro
<li>the software version of the function, declared through the #DECLARE_SIGNATURE_VERSION macro
<li>the software version of SDK used to build the function, declared through the #DECLARE_SIGNATURE_SDKVERSION macro (automatic)
<li>the software status of the function, declared through the #DECLARE_SIGNATURE_STATUS macro (can be openfluid::base::EXPERIMENTAL, openfluid::base::BETA or openfluid::base::STABLE)
</ul>
  
\subsection signapp_ssec Applications range

The informations about applications range is just indicative. it has no effects on coherence or computation. These information are :
<ul>
<li> the domain in which the function can be applied, declared through the #DECLARE_SIGNATURE_DOMAIN macro
<li> the processes simulated by the function, declared through the #DECLARE_SIGNATURE_PROCESS macro
<li> the numerical methods used by the function, declared through the #DECLARE_SIGNATURE_METHOD macro
</ul>


\subsection signdata_ssec Handled data

The data handled by the simulation functions are function data or spatially distributed data, can be read by the function, appended by the function, and/or modified by the function.\n
The function data are parameters passed to the simulation function, they usually are computation parameters. The distributed data are attached to spatial units, and can be simulation variables or units properties.\n   
\n
Read data must have rules associated when they are declared. These rules are :
<ul>
<li>REQUIRED, this means that data must be available or produced on the same time step
<li>REQUIRED_PREV, this means that data must be available or produced on a previous time step
<li>USED, this means that data are used only if they are available or produced on the same time step
<li>USED_PREV,  this means that data are used only if they are available or produced on a previous time step
</ul> 

\subsubsection signdatafunc_ssec Function data


Function data are attached to functions. The declaration macros take 3 arguments : the name of the data, the description of the data (not required), and the unit of the data (not required).
<ul>
<li>#DECLARE_FUNCTION_PARAM
</ul>

\subsubsection signdatadistri_ssec Distributed data

Distributed data are attached to units, and categorized into properties and initial conditions. Simulation functions declares handling distributed data on each units class. The declaration macros take 3 arguments : the name of the data, the description of the data (not required), and the unit of the data (not required).
<ul>
<li>for distributed properties, the declaration macros are #DECLARE_SU_REQUIRED_INICOND, #DECLARE_RS_REQUIRED_INICOND, #DECLARE_GU_REQUIRED_INICOND, #DECLARE_SU_USED_INICOND, #DECLARE_RS_USED_INICOND, #DECLARE_GU_USED_INICOND
<li>for distributed initial conditions, the declaration macros are #DECLARE_SU_REQUIRED_PROPS, #DECLARE_RS_REQUIRED_INICOND, #DECLARE_GU_REQUIRED_PROPS, #DECLARE_SU_USED_PROPS, #DECLARE_RS_USED_PROPS, #DECLARE_GU_USED_PROPS
</ul>


\subsubsection signdatavars_ssec Simulation variables

Simulation variables are produced, read and modified by functions, and attached to distributed units. The declaration macros take 3 arguments : the name of the data, the description of the data (not required), and the unit of the data (not required).

To declare read variables :
<ul>
<li>for required or used vars on the current time step, the declaration macros are #DECLARE_SU_REQUIRED_VAR, #DECLARE_RS_REQUIRED_VAR, #DECLARE_GU_REQUIRED_VAR, #DECLARE_SU_USED_VAR, #DECLARE_RS_USED_VAR, #DECLARE_GU_USED_VAR
<li>for required or used vars on a previous time step, the declaration macros are #DECLARE_SU_REQUIRED_PREVVAR, #DECLARE_RS_REQUIRED_PREVVAR, #DECLARE_GU_REQUIRED_PREVVAR, #DECLARE_SU_USED_PREVVAR, #DECLARE_RS_USED_PREVVAR, #DECLARE_GU_USED_PREVVAR
</ul>

To declare produced or modified variables :
<ul>
<li>for produced vars, the declaration macros are #DECLARE_SU_PRODUCED_VAR, #DECLARE_RS_PRODUCED_VAR, #DECLARE_GU_PRODUCED_VAR
<li>for modified vars, the declaration macros are #DECLARE_SU_UPDATED_VAR, #DECLARE_RS_UPDATED_VAR, #DECLARE_GU_UPDATED_VAR
</ul>


These variables can be scalar (no dimension) or vector (1 dimension). When they are declared in the signature, the variables names suffixed by the [] symbol are vectors, the ones not suffixed are scalars ( myvariable is scalar and myothervariable[] is vector). 

\subsubsection signdataevts_ssec Distributed discrete events

If the simulation function uses distributed discrete events, they must be declared in the signature.

To declare the use of discrete events:
<ul>
<li>#DECLARE_USED_SU_EVENTS, #DECLARE_USED_RS_EVENTS, #DECLARE_USED_GU_EVENTS
</ul>


\subsubsection signdatafiles_ssec Extra files

The simulation function can declare files that it loads. This can help users to furnish the files needed by the function, and also to the kernel to check the presence of the file if required.

To declare extra files:
<ul>
<li>#DECLARE_USED_EXTRAFILE for files used if they are present
<li>#DECLARE_REQUIRED_EXTRAFILE for files that must be present. The presence is checked by the kernel.
</ul>


\subsection signexample_ssec Example

\code

BEGIN_SIGNATURE_HOOK

  DECLARE_SIGNATURE_ID(wxT("water.surf-uz.runoff-infiltration.mseytoux"));
  DECLARE_SIGNATURE_NAME(wxT("Morel-Seytoux production on surface units"));
  DECLARE_SIGNATURE_DESCRIPTION(wxT("Production function computing infiltration and runoff at the surface of a unit 
                                     using the Morel-Seytoux method, based on the Green and Ampt method."));
  DECLARE_SIGNATURE_DOMAIN(wxT("hydrology"));
  DECLARE_SIGNATURE_STATUS(openfluid::base::BETA);

  DECLARE_SIGNATURE_SDKVERSION;

  DECLARE_SIGNATURE_AUTHORNAME(wxT("Moussa R., Fabre J.-C."));
  DECLARE_SIGNATURE_AUTHOREMAIL(wxT("moussa@supagro.inra.fr, fabrejc@supagro.inra.fr"));

  DECLARE_SU_REQUIRED_VAR("water.atm-surf.H.rain",wxT("rainfall height on SU"),wxT("m"));

  DECLARE_SU_PRODUCED_VAR("water.surf.H.runoff",wxT("runoff on the surface of the unit"),wxT("m"));
  DECLARE_SU_PRODUCED_VAR("water.surf.H.infiltration",wxT("infiltration through the surface of the unit"),wxT("m"));

  DECLARE_SU_USED_PREVVAR("water.surf.Q.downstream-su",wxT("output volume at the outlet of the upstream SUs"),wxT("m3/s"));

  DECLARE_SU_REQUIRED_PROPERTY("ks",wxT("hydraulic conductivity when saturated"),wxT("m/s"));
  DECLARE_SU_REQUIRED_PROPERTY("thetares",wxT(""),wxT("m3/m3"));
  DECLARE_SU_REQUIRED_PROPERTY("thetasat",wxT(""),wxT("m3/m3"));
  DECLARE_SU_REQUIRED_PROPERTY("betaMS",wxT(""),wxT(""));
  DECLARE_SU_REQUIRED_PROPERTY("hc",wxT(""),wxT("m"));

  DECLARE_SU_REQUIRED_INICOND("thetaisurf",wxT(""),wxT("m3/m3"));

  DECLARE_FUNCTION_PARAM("resstep",wxT("numerical resolution step for ponding time"),wxT(""));

END_SIGNATURE_HOOK

\endcode

\section split_sec Split and distribute your code into the class methods

A simulation function defines a class, inherited from the openfluid::base::PluggableFunction class. The code have to be distributed into the different methods imposed by this \link openfluid::base::PluggableFunction PluggableFunction\endlink class. You can also develop other methods to structure your source code.
To see how the source code is globally structured, see part \ref emptyfunc.

\subsection splitconstruct_ssec Constructor and destructor

The constructor of the simulation function is called when the function is loaded. You may put here the initialization of you class attributes.\n
The destructor of the simulation function is called when the function is freed, at the end of the execution of the engine. You may put here instruction to free the memory you allocate for the needs of the simulation function (objects, pointed vars, ...).

\subsection splitmethods_ssec Required methods to define

The class defining a simulation function must compound the following methods:
<ul>
<li>\link openfluid::base::PluggableFunction::initParams initParams \endlink
<li>\link openfluid::base::PluggableFunction::prepareData prepareData \endlink
<li>\link openfluid::base::PluggableFunction::checkConsistency checkConsistency \endlink
<li>\link openfluid::base::PluggableFunction::initializeRun initializeRun \endlink
<li>\link openfluid::base::PluggableFunction::runStep runStep \endlink
<li>\link openfluid::base::PluggableFunction::finalizeRun finalizeRun \endlink
</ul> 

The \link openfluid::base::PluggableFunction::initParams initParams \endlink method should be used to retreive function parameters, read from the model.xml file (See \ref funcparams_sec). Once read, the values should be stored into class attributes to be accessed by other methods.  

The \link openfluid::base::PluggableFunction::prepareData prepareData \endlink method should be used to 

The \link openfluid::base::PluggableFunction::checkConsistency checkConsistency \endlink method should be used to

The \link openfluid::base::PluggableFunction::initializeRun initializeRun \endlink method should be used to

The \link openfluid::base::PluggableFunction::runStep runStep \endlink method should be used to

The \link openfluid::base::PluggableFunction::finalizeRun finalizeRun \endlink method should be used to


\section space_sec Handling space

The spatial domain is represented by units of three different classes : openfluid::core::SurfaceUnit, openfluid::core::ReachSegment and openfluid::core::GroundwaterUnit. These classes are derivated from the openfluid::core::HydroObject super-class (unappropriate name, isn't it?). Each unit carries self information that can be exploited through accessor methods (see classes docs), and also properties and variables that can be exploited through special methods (see \ref funcparams_sec and \ref propini_sec).\n  

The spatial domain can be accessed using in different ways: using the access method of the CoreRepository, or use the macros intended for handling spatial entities. The first way is for experimented functions developpers only, so only the second way will be developped here.\n

To parse all units of a specific class, you can use:
<ul>
<li>#DECLARE_SU_ORDERED_LOOP to declare a loop on all \link openfluid::core::SurfaceUnit SurfaceUnit \endlink, #BEGIN_SU_ORDERED_LOOP to begin, #END_LOOP to end 
<li>#DECLARE_RS_ORDERED_LOOP to declare a loop on all \link openfluid::core::ReachSegment ReachSegment \endlink, #BEGIN_SU_ORDERED_LOOP to begin, #END_LOOP to end
<li>#DECLARE_GU_ORDERED_LOOP to declare a loop on all \link openfluid::core::GroundwaterUnit GroundwaterUnit \endlink, #BEGIN_SU_ORDERED_LOOP to begin, #END_LOOP to end
</ul>

To parse a specific list of units of a specific class, you can use:
<ul>
<li>#DECLARE_SU_LIST_LOOP to declare a loop on a list of \link openfluid::core::SurfaceUnit SurfaceUnit \endlink, #BEGIN_SU_LIST_LOOP to begin, #END_LOOP to end 
<li>#DECLARE_RS_LIST_LOOP to declare a loop on a list of \link openfluid::core::ReachSegment ReachSegment \endlink, #BEGIN_SU_LIST_LOOP to begin, #END_LOOP to end
<li>#DECLARE_GU_LIST_LOOP to declare a loop on a list of \link openfluid::core::GroundwaterUnit GroundwaterUnit \endlink, #BEGIN_SU_LIST_LOOP to begin, #END_LOOP to end
</ul>
\n
\code
bool MyFunc::runStep(const openfluid::base::SimulationStatus* SimStatus)
{
  openfluid::core::SurfaceUnit* SU;
  openfluid::core::SurfaceUnit* UpSU;
  std::list<openfluid::core::SurfaceUnit*>* UpSUsList;

  DECLARE_SU_ORDERED_LOOP;
  DECLARE_SU_LIST_LOOP;

  BEGIN_SU_ORDERED_LOOP(SU)

    UpSUsList = SU->getUpstreamSUs();

    BEGIN_SU_LIST_LOOP(UpSUsList,UpSU)
      OPENFLUID_GetVariable(UpSU,wxT("water.surf.Q.downstream-su"),CurrentStep-1,&TmpValue);
    END_LOOP
    
  END_LOOP;
}
\endcode


\section time_sec Handling time

The simulation time information is only available from the \link openfluid::base::PluggableFunction::initializeRun initializeRun \endlink, \link openfluid::base::PluggableFunction::runStep runStep \endlink, and \link openfluid::base::PluggableFunction::finalizeRun finalizeRun \endlink methods. They are accessible through the openfluid::core::SimulationInfo and openfluid::core::SimulationStatus classes passed through methods parameters.\n
The information passed through these classes can be used to get the current time step, the value of the time step in second, the current real date and time, ...\n

\code
bool MyFunc::runStep(const openfluid::base::SimulationStatus* SimStatus)
{
  int CurrentStep;
  openfluid::core::ScalarValue TmpValue;
  openfluid::core::SurfaceUnit* SU;
  DECLARE_SU_ORDERED_LOOP;
  
  CurrentStep = SimStatus->getCurrentStep();  
  
  BEGIN_SU_ORDERED_LOOP(SU)
    OPENFLUID_GetVariable(SU,wxT("the.requested.var"),CurrentStep-1,&TmpValue);
  END_LOOP;      
}
\endcode


\section funcparams_sec Access to function parameters
<I><B>TODO</B></I>

\section vars_sec Access to variables

The values for the simulation variables are attached to the homogeneous units. They can be scalar or vectors.

\subsection varstype_ssec Types

<I><B>TODO</B></I>

openfluid::core::ScalarValue

openfluid::core::VectorValue


\subsection varsaccess_ssec Access

<I><B>TODO</B></I>

The methods to access simulation variables exist in two flavours (scalar and vector), depending on the type you pass for the value:
<ul>
<li>\link openfluid::base::PluggableFunction::OPENFLUID_GetVariable OPENFLUID_GetVariable \endlink
<li>\link openfluid::base::PluggableFunction::OPENFLUID_AppendVariable OPENFLUID_AppendVariable \endlink
<li>\link openfluid::base::PluggableFunction::OPENFLUID_SetVariable OPENFLUID_SetVariable \endlink
<li>\link openfluid::base::PluggableFunction::OPENFLUID_IsVariableExists OPENFLUID_IsVariableExists \endlink
<li>\link openfluid::base::PluggableFunction::OPENFLUID_IsScalarVariableExists OPENFLUID_IsScalarVariableExists \endlink
<li>\link openfluid::base::PluggableFunction::OPENFLUID_IsVectorVariableExists OPENFLUID_IsVectorVariableExists \endlink
</ul>

\section propini_sec Access to distributed properties and initial conditions

<I><B>TODO</B></I>

\link openfluid::base::PluggableFunction::OPENFLUID_GetProperty OPENFLUID_GetProperty \endlink

\link openfluid::base::PluggableFunction::OPENFLUID_SetProperty OPENFLUID_SetProperty \endlink

\link openfluid::base::PluggableFunction::OPENFLUID_GetIniCondition OPENFLUID_GetIniCondition \endlink




\section events_sec Access to distributed events

<I><B>TODO</B></I>

\section persist_sec Persistance of internal data

<I><B>TODO</B></I>
<ul>
<li>\ref IDFloatMap
<li>\ref IDDoubleMap
<li>\ref IDIntMap
<li>\ref IDBoolMap
<li>\ref IDScalarValueMap
<li>\ref IDVectorValueMap
<li>\ref IDVectorValuePtrMap
</ul>

\section warnerr_sec Raising warnings and errors

<I><B>TODO</B></I>

\link openfluid::base::PluggableFunction::OPENFLUID_RaiseWarning OPENFLUID_RaiseWarning \endlink

\link openfluid::base::PluggableFunction::OPENFLUID_RaiseError OPENFLUID_RaiseError \endlink

dated and undated


\section tools_sec Available tools

<I><B>TODO</B></I>



\section fortran_sec Calling Fortran source code

<I><B>TODO</B></I>

 
*/