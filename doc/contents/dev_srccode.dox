/**

\page dev_srccode Development of the simulator source code


\section dev_srccode_general General information about simulators architecture

\subsection dev_srccode_general_methods Simulator methods and framework interactions

\todo describe methods, returned values and general interaction sequence


\subsection dev_srccode_general_datatypes OpenFLUID data types

Simulation data exchanged through the OpenpenFLUID framework should be typed with an OpenFLUID defined type.\n
The available simple types are:
<ul>
<li> openfluid::core::BooleanValue for storing boolean values
<li> openfluid::core::IntegerValue for storing long integer values
<li> openfluid::core::DoubleValue for storing double precision values
<li> openfluid::core::StringValue for storing string values
</ul>

The available compound types are:
<ul>
<li> openfluid::core::VectorValue for storing vector data
<li> openfluid::core::MatrixValue for storing matrix data
<li> openfluid::core::MapValue for storing associative keys-value data
</ul>

A specific type is available for storing non-existing values:
<ul>
<li> openfluid::core::NullValue
</ul>
\n


Simulation data are stored using these types : 
<ul>
<li>Simulation variables : stored as any type
<li>Spatial attributes : stored as openfluid::core::StringValue, 
and can be converted to any other type
<li>Simulator parameters : stored as openfluid::core::StringValue, 
and can be converted to any other type
<li>Informations associated to events : stored as openfluid::core::StringValue, 
and can be converted to any other type
</ul>

Each data type can be converted to and from openfluid::core::StringValue (as far as the string format is correct). 


Simulation variables can be typed or untyped. 
This is set at the declaration of these variables (see \link dev_signature_data_vars \endlink).\n
In case of typed variables, each value of the variable must be of the type of the variable.
In case of untyped variables, values for the variable can be of any type. 



\section dev_srccode_space Handling the spatial domain

\subsection dev_srccode_space_parse Browsing the spatial graph

The spatial graph represents the spatial domain where coupled simulation will be applied.
Browsing this graph in different ways is a common task in simulators.
This graph can be browsed using predefined macros.\n

\subsubsection dev_srccode_space_parse_seq Sequential browsing

To browse all units of a specific units class, following the process order,
you can use the
\if doc-is-latex 
OPENFLUID_UNITS_ORDERED_LOOP
\else
#OPENFLUID_UNITS_ORDERED_LOOP
\endif
macro.\n 

To browse all units of the spatial domain, following the process order,
you can use the
\if doc-is-latex 
OPENFLUID_ALLUNITS_ORDERED_LOOP
\else
#OPENFLUID_ALLUNITS_ORDERED_LOOP
\endif
macro.\n 

To parse a specific list of of spatial units, you can use the
\if doc-is-latex 
OPENFLUID_UNITSLIST_LOOP
\else
#OPENFLUID_UNITSLIST_LOOP
\endif
 macro. 

\n
The code below shows spatial graph browsing examples. 
The first part shows how to browse all units of the SU units class, and browse the \"From\" units for each SU unit.
The second part show how to browse all units of the second part. 
\code
openfluid::base::SchedulingRequest runStep()
{
  openfluid::core::Unit* SU;
  openfluid::core::Unit* UU;
  openfluid::core::Unit* UpSU;
  openfluid::core::UnitsPtrList_t* UpSUsList;
  openfluid::core::DoubleValue TmpValue;

  OPENFLUID_UNITS_ORDERED_LOOP("SU",SU)
  {
    UpSUsList = SU->getFromUnits("SU");

    OPENFLUID_UNITSLIST_LOOP(UpSUsList,UpSU)
    {
      // do something here
    }    
  }  
  
  OPENFLUID_ALLUNITS_ORDERED_LOOP(UU)
  {  
    // do something here with UU pointer
  }
  
  return DefaultDeltaT();
}
\endcode


\subsubsection dev_srccode_space_parse_par Parallel processing using multithreading

To apply a process on all units of a specific units class, following the process order, 
you can use the #APPLY_UNITS_ORDERED_LOOP_THREADED. 
This macro applies a given method of the simulator to every unit of the units class.
Extra arguments can be passed (see example below).\n 

To apply a process on all units of the spatial domain, following the process order, 
you can use the #APPLY_ALLUNITS_ORDERED_LOOP_THREADED.
This macro applies a given method of the simulator to every unit of the units class.
Extra arguments can be passed (see example below).\n 

The fist argument of the the method passed to the macro must be an openfluid::core::Unit*
as it represents the currently processed spatial unit. 

\n
The code below shows how to apply a method in parallel over the spatial graph.
\code
void computeA(openfluid::core::Unit* aUnit)
{
 // compute something
 // use/produce variables
}


void computeB(openfluid::core::Unit* U,
              const openfluid::base::SimulationStatus* SimStatus, 
              const double Coeff)
{
 // compute something else, with extra args
 // use/produce variables
}


openfluid::base::SchedulingRequest runStep()
{

  APPLY_UNITS_ORDERED_LOOP_THREADED("SU",MyFunc::computeA);
  APPLY_UNITS_ORDERED_LOOP_THREADED("TU",MyFunc::computeB, SimStatus, 2.5);
  
  APPLY_ALLUNITS_ORDERED_LOOP_THREADED(MyFunc::computeA);

  return DefaultDeltaT();
}
\endcode


Please note:
<ul>
<li>If a spatial loop is used inside other spatial loop, it is recommended to use multithreading in only one loop.
<li>In case of concurrent data access, it is strongly recommended to use mutex locks for thread safe data handling.
<li>Concurrent parsing using multithreading should improve computing performance, reducing simulations durations.
But in case of very short computing durations, the cost of multithreading management
may counterbalance the speed improvements of concurrent computing. 

</ul>


\subsection dev_srccode_space_query Querying the spatial graph

The spatial domain graph can be queried during simulations, in order to get
informations about spatial units and connections.

The following methods are available:
\if doc-is-latex
<ul>
<li>OPENFLUID_IsUnitExist
<li>OPENFLUID_IsUnitClassExist
<li>OPENFLUID_GetUnitsCount
<li>OPENFLUID_IsUnitConnectedTo
<li>OPENFLUID_IsUnitConnectedFrom
<li>OPENFLUID_IsUnitChildOf
<li>OPENFLUID_IsUnitParentOf
</ul>
\else
<ul>
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_IsUnitExist OPENFLUID_IsUnitExist \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_IsUnitClassExist OPENFLUID_IsUnitClassExist \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetUnitsCount OPENFLUID_GetUnitsCount \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_IsUnitConnectedTo OPENFLUID_IsUnitConnectedTo \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_IsUnitConnectedFrom OPENFLUID_IsUnitConnectedFrom \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_IsUnitChildOf OPENFLUID_IsUnitChildOf \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_IsUnitParentOf OPENFLUID_IsUnitParentOf \endlink
</ul>
\endif

\subsection dev_srccode_space_mod Modifying the spatial graph

The spatial graph can be statically defined through the input dataset.
It can also be defined and modified dynamically during simulations, using primitives allowing to 
create and delete spatial units, and also to add and remove connections between these
spatial units.\n
Although the creation, deletion and modification of connections are allowed at any stage of the simulation,
the creation, deletion and modification of spatial units are currently allowed only during the data preparation stage
(i.e. in the prepareData() method of the simulator).\n
For consistent use of simulators which modify the spatial domain graph, 
please fill the signature with the correct directives. See \ref dev_signature_data_spatial.

\subsubsection dev_srccode_space_mod_units Creating and deleting spatial units

In order to create and delete units, you can use the following methods:
\if doc-is-latex
<ul>
<li>OPENFLUID_AddUnit
<li>OPENFLUID_DeleteUnit
</ul>
\else
<ul>
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_AddUnit OPENFLUID_AddUnit \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_DeleteUnit OPENFLUID_DeleteUnit \endlink
</ul>
\endif


\subsubsection dev_srccode_space_mod_cnx Adding and removing spatial connections

Connections between spatial units can be of two types:
<ul>
<li>"From-To" connections, linking spatial units topologically. These connections are usually used in "fluxes-like" processes.
<li>"Parent-Child" connections, linking units hierarchically.
</ul>

In order to add and remove connections, you can use the following methods, whenever during simulations:
\if doc-is-latex
<ul>
<li>OPENFLUID_AddFromToConnection
<li>OPENFLUID_AddChildParentConnection
<li>OPENFLUID_RemoveFromToConnection
<li>OPENFLUID_RemoveChildParentConnection
</ul>
\else
<ul>
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_AddFromToConnection OPENFLUID_AddFromToConnection \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_AddChildParentConnection OPENFLUID_AddChildParentConnection \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_RemoveFromToConnection OPENFLUID_RemoveFromToConnection \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_RemoveChildParentConnection OPENFLUID_RemoveChildParentConnection \endlink
</ul>
\endif
\n
<i>Example:</i>
\n
\code
void prepareData()
{

 /*
      TU.1         TU.2
        |            |
        -->  TU.22 <--
               |
               --> TU.18
                     |
          TU.52 --> OU.5 <-- OU.13
                     |
                     --> OU.25

       VU1 <-> VU2

   with:
   TU1, TU2, TU22, TU18 are children of VU1
   TU52, OU5, OU13, OU25 are children of VU2
*/

  OPENFLUID_AddUnit("VU",1,1);
  OPENFLUID_AddUnit("VU",2,2);
  OPENFLUID_AddUnit("TU",1,1);
  OPENFLUID_AddUnit("TU",2,1);
  OPENFLUID_AddUnit("TU",22,2);
  OPENFLUID_AddUnit("TU",18,3);
  OPENFLUID_AddUnit("TU",52,1);
  OPENFLUID_AddUnit("OU",5,4);
  OPENFLUID_AddUnit("OU",13,1);
  OPENFLUID_AddUnit("OU",25,5);

  OPENFLUID_AddFromToConnection("VU",1,"VU",2);
  OPENFLUID_AddFromToConnection("VU",2,"VU",1);
  OPENFLUID_AddFromToConnection("TU",1,"TU",22);
  OPENFLUID_AddFromToConnection("TU",2,"TU",22);
  OPENFLUID_AddFromToConnection("TU",22,"TU",18);
  OPENFLUID_AddFromToConnection("TU",18,"OU",5);
  OPENFLUID_AddFromToConnection("TU",52,"OU",5);
  OPENFLUID_AddFromToConnection("OU",13,"OU",5);
  OPENFLUID_AddFromToConnection("OU",5,"OU",25);

  OPENFLUID_AddChildParentConnection("TU",1,"VU",1);
  OPENFLUID_AddChildParentConnection("TU",2,"VU",1);
  OPENFLUID_AddChildParentConnection("TU",22,"VU",1);
  OPENFLUID_AddChildParentConnection("TU",18,"VU",1);
  OPENFLUID_AddChildParentConnection("TU",52,"VU",2);
  OPENFLUID_AddChildParentConnection("OU",5,"VU",2);
  OPENFLUID_AddChildParentConnection("OU",13,"VU",2);
  OPENFLUID_AddChildParentConnection("OU",25,"VU",2);
}
\endcode

\subsubsection dev_srccode_space_mod_gen Generating spatial domain graphs automatically

Generators can help to automatically build a spatial domain graph, or to extend an existing one.\n
Currently, only one spatial domain generator is available:
\if doc-is-latex
<ul>
<li>OPENFLUID_BuildUnitsMatrix
</ul>
\else
<ul>
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_BuildUnitsMatrix OPENFLUID_BuildUnitsMatrix \endlink
</ul>
\endif


\section dev_srccode_time Informations about simulation time

Simulators can access to informations about simulation time.
There are constant time informations, such as simulation duration or begin and end date,
and evolutive informations such as current time index.

Constant informations about simulation time can be accessed from any part of the simulator
(except from the constructor), using the following methods:
\if doc-is-latex
<ul>
<li>OPENFLUID_GetBeginDate returns the beginning date of the simulation
<li>OPENFLUID_GetEndDate returns the end date of the simulation
<li>OPENFLUID_GetSimulationDuration returns the duration of the simulation (in seconds)
<li>OPENFLUID_GetDefaultDeltaT returns the default time step of the simulation (in seconds),
given in the input dataset
</ul>
\else
<ul>
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetBeginDate OPENFLUID_GetBeginDate \endlink 
returns the beginning date of the simulation
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetEndDate OPENFLUID_GetEndDate \endlink 
returns the end date of the simulation
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetSimulationDuration OPENFLUID_GetSimulationDuration \endlink
returns the duration of the simulation (in seconds)
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetDefaultDeltaT OPENFLUID_GetDefaultDeltaT \endlink
returns the default time step of the simulation (in seconds),
given in the input dataset
</ul>
\endif

Evolutive informations about simulation time can be accessed only from specific parts 
of the simulator, using the following methods:
\if doc-is-latex
<ul>
<li>OPENFLUID_GetCurrentTimeIndex 
returns the current time index (in seconds) of the simulation,
and is available from the initializeRun(), runStep() and finalizeRun() methods of the simulator
<li>OPENFLUID_GetCurrentDate returns the current time index (in seconds) of the simulation,
and is available from the initializeRun(), runStep() and finalizeRun() methods of the simulator
<li>OPENFLUID_GetPreviousRunTimeIndex returns the time index
corresponding to the previous execution of the simulator,
and is available from the runStep() and finalizeRun() methods of the simulator  
</ul>
\else
<ul>
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetCurrentTimeIndex OPENFLUID_GetCurrentTimeIndex \endlink
returns the current time index (in seconds) of the simulation,
and is available from the initializeRun(), runStep() and finalizeRun() methods of the simulator
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetCurrentDate OPENFLUID_GetCurrentDate \endlink returns the current time index (in seconds) of the simulation,
and is available from the initializeRun(), runStep() and finalizeRun() methods of the simulator
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetPreviousRunTimeIndex OPENFLUID_GetPreviousRunTimeIndex \endlink returns the time index
corresponding to the previous execution of the simulator,
and is available from the runStep() and finalizeRun() methods of the simulator  
</ul>
\endif


\n
Example of code:
\code
openfluid::base::SchedulingRequest runStep()
{
  long int Duration = OPENFLUID_GetSimulationDuration();

  long int CurrentIndex = OPENFLUID_GetCurrentTimeIndex();
  openfluid::core::DateTime CurrentDT = OPENFLUID_GetCurrentDate();  
  
  return DefaultDeltaT();      
}
\endcode


\section dev_srccode_simparams Simulator parameters

\todo

Simulators parameters are passed through the model.fluidx file. They can be accessed in the source code from the \link openfluid::ware::PluggableSimulator::initParams initParams \endlink method of the simulation function, using \link openfluid::ware::PluggableSimulator::OPENFLUID_GetFunctionParameter OPENFLUID_GetFunctionParameter\endlink. The requested parameter name must be the same as the one used in the model.fluidx file.\n
\n
<i>model.fluidx file:</i>
\code
<?xml version="1.0" standalone="yes"?>
<openfluid>
  <model>
   
    <simulator ID="myfunction">
      <param name="myparam" value="2" />          
    </simulator>
    
  </model>
</openfluid>            
\endcode
\n
<i>initParam method of the simulation function source code:</i>
\code
bool MyFunction::initParams(openfluid::core::FuncParamsMap_t Params)
{
  m_MyParam = 0; //default value
  OPENFLUID_GetFunctionParameter(Params,"myparam",m_MyParam);

  return true;
}
\endcode

To be reused in other part of the simulation function, the variable to store the value of function parameters should be declared as class variable. The parameters type can be string, double, integer, boolean, vector of string, vector of double, ... (see definitions of \link openfluid::ware::PluggableSimulator::OPENFLUID_GetFunctionParameter OPENFLUID_GetFunctionParameter \endlink to get more information about available types). 


\section dev_srccode_attrs Spatial attributes

\todo


In order to access to input data provided through standard input files, you can use the following methods.
They are usable from \link openfluid::ware::PluggableSimulator::initializeRun initializeRun\endlink, \link openfluid::ware::PluggableSimulator::runStep runStep\endlink, and \link openfluid::ware::PluggableSimulator::finalizeRun finalizeRun\endlink:  
<ul>
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetInputData OPENFLUID_GetInputData \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_SetInputData OPENFLUID_SetInputData \endlink
</ul>

The name of the accessed input data must match the name given in the standard input files.


\section dev_srccode_vars Simulation variables

\todo


The values for the simulation variables are attached to the homogeneous units.

Many methods to access simulation variables exist, depending on the type you pass for the value:
<ul>
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_GetVariable OPENFLUID_GetVariable \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_AppendVariable OPENFLUID_AppendVariable \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_SetVariable OPENFLUID_SetVariable \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_IsVariableExist OPENFLUID_IsVariableExist \endlink
<li>\link openfluid::ware::PluggableSimulator::OPENFLUID_IsVariableExist OPENFLUID_IsTypedVariableExist \endlink
</ul>

They can be accessed only from the \link openfluid::ware::PluggableSimulator::runStep runStep \endlink method.
\n
\n
<i>Example:</i>
\n
\code
bool MyFunction::runStep(const openfluid::base::SimulationStatus* SimStatus)
{
  int CurrentStep;
  double TmpValue;
  openfluid::core::Unit* SU;

  CurrentStep = SimStatus->getCurrentStep();

  OPENFLUID_UNITS_ORDERED_LOOP("SU",SU)
  {
    OPENFLUID_GetVariable(SU,"MyVar",CurrentStep,TmpValue);
    TmpValue = TmpValue * 2;
    OPENFLUID_AppendVariable(SU,"MyVarX2",TmpValue);
  }
  
  return true;
}
\endcode




\section dev_srccode_events Events

\todo

A discrete event is defined in the class openfluid::core::Event. It is defined by a date and a list of key-value information that can be accessed by methods proposed by the openfluid::core::Event class.\n 
A collection of discrete events can be contained by an openfluid::core::EventsCollection class.\n
\n
To get a collection of events occuring during a period on a given unit, you should use the \link openfluid::ware::PluggableSimulator::OPENFLUID_GetEvents OPENFLUID_GetEvents \endlink method.
It returns an openfluid::core::EventsCollection that can be processed.\n
In order to process an event collection, you can parse it using specific macros:
<ul>
<li>#DECLARE_EVENT_COLLECTION_LOOP to declare a loop on an event collection,
<li>#BEGIN_EVENT_COLLECTION_LOOP to begin the loop,
<li>#END_LOOP to finish the loop.
</ul>
At each iteration, the current event can be processed.\n
\n
To add an event occuring on a specific \link openfluid::core::Unit Unit \endlink at specific date, you can use the
\link openfluid::ware::PluggableSimulator::OPENFLUID_AppendEvent OPENFLUID_AppendEvent \endlink method.\n

\n
<i>Example of process of events occurring on the current time step:</i>
\code
bool MyFunction::runStep(const openfluid::base::SimulationStatus* SimStatus)
{
  openfluid::core::Unit* SU;
  openfluid::core::EventCollection EvColl;
  openfluid::core::Event* Ev;
  std::list<openfluid::core::Event* > *EvList;
  openfluid::core::DateTime BTime, ETime;


  BTime = SimStatus->getCurrentTime();
  ETime = BTime + SimStatus->getTimeStep()-1;

  OPENFLUID_UNITS_ORDERED_LOOP("SU",SU)
  {

    EvColl.clear();

    OPENFLUID_GetEvents(SU,BTime,ETime,EvColl);
    EvList = EvColl.getEventsList();

    OPENFLUID_EVENT_COLLECTION_LOOP(EvColl.getEventsList(),Ev)
    {
      if (Ev->isInfoEquals("molecule","glyphosate"))
      {
        // process the event
      }
    }

  }

  return true;
}
\endcode



\section dev_srccode_state Internal state data

\todo

In order to keep the status of the simulation function between calls (from the a time step to the next one), internal variables can be stored as class attributes. The class attributes are persistant during the whole life of the simulation function.\n
To store distributed values, data structures are available to associate a unit ID to a value. These data structures exist for different types of data:   
<ul>
<li>\ref openfluid::core::IDFloatMap
<li>\ref openfluid::core::IDDoubleMap
<li>\ref openfluid::core::IDIntMap
<li>\ref openfluid::core::IDBoolMap
<li>\ref openfluid::core::IDDoubleValueMap
<li>\ref openfluid::core::IDVectorValueMap
<li>\ref openfluid::core::IDVectorValuePtrMap
</ul>


<i>declaration of the ID-map structure in the .h file :</i>
\code
class MyFunction : public openfluid::ware::PluggableSimulator
{
  private:

    openfluid::core::IDDoubleMap m_LastValue;

  public:
  
    // rest of the declaration of the class 

}
\endcode


<i>usage of the ID-map structure in the .cpp file :</i>
\code
bool MyFunction::runStep(const openfluid::base::SimulationStatus* SimStatus)
{
  int ID;
  double TmpValue;
  openfluid::core::Unit* SU;

  OPENFLUID_UNITS_ORDERED_LOOP("SU",SU)
  {

    ID = SU->getID();

    TmpValue = TmpValue + m_LastValue[ID]

    OPENFLUID_AppendVariable(SU,"MyVar",TmpValue);

    m_LastValue[ID] = TmpValue;

  }

  return true;
}
\endcode


\section dev_srccode_runenv Runtime environment

\todo


The runtime environment are informations about the context during execution of
the simulation: input and output directories, options passed to
the OpenFLUID application at runtime (verbose/quiet mode, ...)...

They are accessible from simulation functions using the \link openfluid::ware::PluggableSimulator::OPENFLUID_GetRunEnvironment OPENFLUID_GetRunEnvironment \endlink method.

\code
bool MyFunction::initializeRun(const openfluid::base::SimulationInfo* SimInfo)
{
  std::string InputDir;

  OPENFLUID_GetRunEnvironment("dir.input",&InputDir);

  // the current input directory is now available through the InputDir local variable 

  return true;
}
\endcode


The keys for requesting runtime environment information are:
<ul>
<li>dir.input [string] : the current input directory
<li>dir.output [string] : the current output directory
<li>dir.temp [string] : the dirrectory for temporary files
<li>mode.cleanoutput [boolean] : cleaning output dir before data saving is enabled/disabled
<li>mode.saveresults [boolean] : result saving in output directory is enabled/disabled
<li>mode.writereport [boolean] : simulation report saving is enabled/disabled
</ul>


\todo code example


\section dev_srccode_msgs Logs, warnings, errors

\subsection dev_srccode_msgs_log Log messages from simulation functions

\todo


Simulation functions can log messages to both console display and files using 
the \link openfluid::ware::PluggableSimulator::OPENFLUID_Logger OpenFLUID_Logger\endlink feature:
<ul>
<li>\link openfluid::base::StdoutAndFileOutputStream::getFile() OpenFLUID_Logger.getFile() \endlink
to log messages to file only
<li>\link openfluid::base::StdoutAndFileOutputStream::getStdout() OpenFLUID_Logger.getStdout() \endlink
to log messages to console only
<li>\link openfluid::base::StdoutAndFileOutputStream::get() OpenFLUID_Logger.get() \endlink
to log messages to file and console.
</ul>


The messages logged to files are put in a file named with the ID of the 
simulation function suffixed by .log, placed in the simulation output directory.


The OpenFLUID_Logger facility is the recommended way to log messages. Please avoid using std::cout
or similar C++ facilities.   

<i>Example:</i>

\code
 bool runStep(const openfluid::base::SimulationStatus* /*SimStatus*/)
{
  openfluid::core::Unit* TU;

  OPENFLUID_Logger.get() << "This is a message to both file and console" << std::endl;
  OPENFLUID_Logger.getFile() << "This is a message to file only" << std::endl;
  OPENFLUID_Logger.getStdout() << "This is a message to console only" << std::endl;

  OPENFLUID_UNITS_ORDERED_LOOP("TestUnits",TU)
  {
    OPENFLUID_Logger.get() << "TestUnits " << TU->getID() << std::endl;
  }

  return true;
}
\endcode


 

\subsection dev_srccode_msgs_warnerr Raise warnings and errors

\todo

In order to trace error and warnings during the run of a simulation, simulation 
functions can raise error and warning messages to inform the framework 
that something wrong or critical had happened. An error stops the simulation the 
next time the OpenFLUID framework take the control, a warning does 
not stop the simulation. Error and warnings are reported in the simulation report 
(siminfo.out file). They both can be dated with the number of the time step when the warning or error occurs. \n  

To raise a warning you can use \link openfluid::ware::PluggableSimulator::OPENFLUID_RaiseWarning OPENFLUID_RaiseWarning\endlink, to raise an error you can use \link openfluid::ware::PluggableSimulator::OPENFLUID_RaiseError OPENFLUID_RaiseError\endlink. \n

As already mentioned, an error stops the simulation the next time the framework takes control of the simulation.

<i>Example:</i>

\code
bool Myfunction::checkConsistency()
{
  double TmpValue;
  openfluid::core::Unit* SU;
    
  OPENFLUID_UNITS_ORDERED_LOOP("SU",SU)
  {
    OPENFLUID_GetInputData(SU,"MyVar",TmpValue);
    
    if (TmpValue <= 0)
    {
      OPENFLUID_RaiseError("my.function","Wrong value for the MyProp distributed property on SU");
      return false;
    }    
  }

  return true;
}

\endcode 




\section dev_srccode_debug Debugging

\todo

Debugging macros adds informations on standard output stream (usually displayed on screen). It allows developpers to trace various information during simulations.\n 
They are enabled only when debug build is enabled. They are ignored for other build types.\n 

In order to enable debug build mode, the option <tt>-DCMAKE_BUILD_TYPE=Debug</tt> must be added to the cmake command (e.g. <tt>cmake \<path to src\> -DCMAKE_BUILD_TYPE=Debug</tt>).
\verbatim
cmake .. -DCMAKE_BUILD_TYPE=Debug
\endverbatim
This debug build mode can be disabled using the release mode, with the option <tt>-DCMAKE_BUILD_TYPE=Release</tt>.\n
\n

The following macros are available for debugging:
<ul>
<li>#OFDBG_LOCATE for file/line location where the macro is called 
<li>#OFDBG_MESSAGE adding the message given as an argument 
<li>#OFDBG_UNIT for information about the unit given as an argument
<li>#OFDBG_UNIT_EXTENDED for extended information about the unit given as an argument
<li>#OFDBG_EVENT for information about the event given as an argument
<li>#OFDBG_EVENTCOLLECTION for information about the event collection given as an argument
</ul>
\n
<i>Example:</i>

\code
 bool runStep(const openfluid::base::SimulationStatus* SimStatus)
{
  openfluid::core::Unit* TU;
  openfluid::core::DateTime BeginDate,EndDate;
  openfluid::core::EventsCollection EvColl;

  OFDBG_LOCATE;

  BeginDate = SimStatus->getCurrentTime();
  EndDate = SimStatus->getCurrentTime() + SimStatus->getTimeStep() -1;


  OPENFLUID_UNITS_ORDERED_LOOP("TU",TU)
  {
     OFDBG_UNIT_EXTENDED(TU);    

     EvColl.clear();
     OPENFLUID_GetEvents(TU,BeginDate,EndDate,EvColl);
     OFDBG_EVENTCOLLECTION(EvColl);
  }

  return true;
}
\endcode



\section dev_srccode_fortran Fortran 77/90 source code integration

\todo

The C++ - Fortran interface is defined in the openfluid/tools/FortranCPP.hpp file.
In order to execute Fortran code from a simulation function, this Fortran source code have to be wrapped into a subroutine that will be called from the C++ code of the simulation function. To help programmers to achieve this wrapping operation, the FortranCPP.h file defines macros. These macros allows calls of Fortran77 and Fortran90 source code. You are invited to browse the FortranCPP.h file to get more information about these macros.\n


\n
<I>Fortran source code (FSubr.f90):</I>
\code
subroutine displayvector(Fsize,vect)

implicit none

integer Fsize,ifrom
real*8 vect(Fsize)

write(*,*) 'size',Fsize
write(*,*) (vect(i),i=1,Fsize)

return
end
\endcode
\n
<I>Declaration block int the .cpp file, located just after the function signature (MyFunc.cpp):</I>
\code
BEGIN_EXTERN_FORTRAN
  EXTERN_FSUBROUTINE(displayvector)(FINT *Size, FREAL8 *Vect);
END_EXTERN_FORTRAN
\endcode
\n
<I>Call of the fortran subroutine from the initializeRun method (MyFunc.cpp):</I>
\code

#include <openfluid/tools/FortranCPP.hpp>

bool MyFunction::initializeRun(const openfluid::base::SimulationInfo* SimInfo)
{
  openfluid::core::VectorValue MyVect;
  
  MyVect = openfluid::core::VectorValue(15,9);
  int Size = MyVect.getSize();

  CALL_FSUBROUTINE(displayvector)(&Size,(MyVect.getData()));

  return true;
}
\endcode

\n
The compilation and linking of fortran source code is automatically done when adding fortran source files to the SIM_FORTRAN variable in the CMake.in.config file (See \ref dev_createsim_exmpl).



\section dev_srccode_misctools Miscellaneous tools

\todo

The tools have been developped to help function developpers in the set up of data processing or numerical computation. They are available in the namespace openfluid::tools.
To get more information on theses tools and how to you use it, your are invited to browse the provides header files (.hpp), located in the openfluid/tools include directory.    

This involves the following classes and functions (non-exhaustive list): 
<ul>
  <li>openfluid::tools::ColumnTextParser
  <li>openfluid::tools::DateTimeSerie
  <li>openfluid::tools::DistributeInterpolate    
  <li>openfluid::tools::IsCloseEnough    
  <li>openfluid::tools::IsVeryClose    
</ul>

In order to use these tools, the header file <openfluid/tools.hpp> must be included in your source code.

\see openfluid::tools

*/
